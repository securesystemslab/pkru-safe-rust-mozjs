wrap!(jsapi: pub fn GetRealmGlobalOrNull(realm: Handle<*mut Realm>) -> *mut JSObject);
wrap!(jsapi: pub fn ComputeThis(cx: *mut JSContext, vp: *mut Value, thisObject: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn IsArray(cx: *mut JSContext, obj: HandleObject, isArray: *mut bool) -> bool);
wrap!(jsapi: pub fn IsArray1(cx: *mut JSContext, obj: HandleObject, answer: *mut IsArrayAnswer) -> bool);
wrap!(jsapi: pub fn EncodeScript(cx: *mut JSContext, buffer: *mut TranscodeBuffer, script: Handle<*mut JSScript>) -> TranscodeResult);
wrap!(jsapi: pub fn EncodeInterpretedFunction(cx: *mut JSContext, buffer: *mut TranscodeBuffer, funobj: HandleObject) -> TranscodeResult);
wrap!(jsapi: pub fn DecodeScript(cx: *mut JSContext, buffer: *mut TranscodeBuffer, scriptp: MutableHandle<*mut JSScript>, cursorIndex: usize) -> TranscodeResult);
wrap!(jsapi: pub fn DecodeScript1(cx: *mut JSContext, range: *const TranscodeRange, scriptp: MutableHandle<*mut JSScript>) -> TranscodeResult);
wrap!(jsapi: pub fn DecodeInterpretedFunction(cx: *mut JSContext, buffer: *mut TranscodeBuffer, funp: MutableHandle<*mut JSFunction>, cursorIndex: usize) -> TranscodeResult);
wrap!(jsapi: pub fn StartIncrementalEncoding(cx: *mut JSContext, script: Handle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn FinishIncrementalEncoding(cx: *mut JSContext, script: Handle<*mut JSScript>, buffer: *mut TranscodeBuffer) -> bool);
wrap!(jsapi: pub fn ObjectToCompletePropertyDescriptor(cx: *mut JSContext, obj: HandleObject, descriptor: Handle<Value>, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn FromPropertyDescriptor(cx: *mut JSContext, desc: Handle<PropertyDescriptor>, vp: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn ProtoKeyToId(cx: *mut JSContext, key: JSProtoKey, idp: MutableHandleId));
wrap!(jsapi: pub fn ToPrimitive(cx: *mut JSContext, obj: HandleObject, hint: JSType, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn OrdinaryHasInstance(cx: *mut JSContext, objArg: HandleObject, v: HandleValue, bp: *mut bool) -> bool);
wrap!(jsapi: pub fn InstanceofOperator(cx: *mut JSContext, obj: HandleObject, v: HandleValue, bp: *mut bool) -> bool);
wrap!(jsapi: pub fn Call(cx: *mut JSContext, thisv: HandleValue, fun: HandleValue, args: *const HandleValueArray, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn Construct(cx: *mut JSContext, fun: HandleValue, newTarget: HandleObject, args: *const HandleValueArray, objp: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn Construct1(cx: *mut JSContext, fun: HandleValue, args: *const HandleValueArray, objp: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn IsMapObject(cx: *mut JSContext, obj: HandleObject, isMap: *mut bool) -> bool);
wrap!(jsapi: pub fn IsSetObject(cx: *mut JSContext, obj: HandleObject, isSet: *mut bool) -> bool);
wrap!(jsapi: pub fn GetSelfHostedFunction(cx: *mut JSContext, selfHostedName: *const ::std::os::raw::c_char, id: HandleId, nargs: ::std::os::raw::c_uint) -> *mut JSFunction);
wrap!(jsapi: pub fn NewFunctionFromSpec(cx: *mut JSContext, fs: *const JSFunctionSpec, id: HandleId) -> *mut JSFunction);
wrap!(jsapi: pub fn CloneFunctionObject(cx: *mut JSContext, funobj: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn CloneFunctionObject1(cx: *mut JSContext, funobj: HandleObject, scopeChain: *mut AutoObjectVector) -> *mut JSObject);
wrap!(jsapi: pub fn FinishDynamicModuleImport(cx: *mut JSContext, referencingPrivate: HandleValue, specifier: HandleString, promise: HandleObject) -> bool);
wrap!(jsapi: pub fn CompileModule(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<u16>, moduleRecord: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn ModuleInstantiate(cx: *mut JSContext, moduleRecord: HandleObject) -> bool);
wrap!(jsapi: pub fn ModuleEvaluate(cx: *mut JSContext, moduleRecord: HandleObject) -> bool);
wrap!(jsapi: pub fn GetRequestedModules(cx: *mut JSContext, moduleRecord: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn GetRequestedModuleSpecifier(cx: *mut JSContext, requestedModuleObject: HandleValue) -> *mut JSString);
wrap!(jsapi: pub fn GetRequestedModuleSourcePos(cx: *mut JSContext, requestedModuleObject: HandleValue, lineNumber: *mut u32, columnNumber: *mut u32));
wrap!(jsapi: pub fn GetModuleScript(moduleRecord: HandleObject) -> *mut JSScript);
wrap!(jsapi: pub fn PropertySpecNameEqualsId(name: *const ::std::os::raw::c_char, id: HandleId) -> bool);
wrap!(jsapi: pub fn CreateError(cx: *mut JSContext, type_: JSExnType, stack: HandleObject, fileName: HandleString, lineNumber: u32, columnNumber: u32, report: *mut JSErrorReport, message: HandleString, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn GetWeakMapEntry(cx: *mut JSContext, mapObj: HandleObject, key: HandleObject, val: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn SetWeakMapEntry(cx: *mut JSContext, mapObj: HandleObject, key: HandleObject, val: HandleValue) -> bool);
wrap!(jsapi: pub fn MapSize(cx: *mut JSContext, obj: HandleObject) -> u32);
wrap!(jsapi: pub fn MapGet(cx: *mut JSContext, obj: HandleObject, key: HandleValue, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn MapHas(cx: *mut JSContext, obj: HandleObject, key: HandleValue, rval: *mut bool) -> bool);
wrap!(jsapi: pub fn MapSet(cx: *mut JSContext, obj: HandleObject, key: HandleValue, val: HandleValue) -> bool);
wrap!(jsapi: pub fn MapDelete(cx: *mut JSContext, obj: HandleObject, key: HandleValue, rval: *mut bool) -> bool);
wrap!(jsapi: pub fn MapClear(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn MapKeys(cx: *mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn MapValues(cx: *mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn MapEntries(cx: *mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn MapForEach(cx: *mut JSContext, obj: HandleObject, callbackFn: HandleValue, thisVal: HandleValue) -> bool);
wrap!(jsapi: pub fn SetSize(cx: *mut JSContext, obj: HandleObject) -> u32);
wrap!(jsapi: pub fn SetHas(cx: *mut JSContext, obj: HandleObject, key: HandleValue, rval: *mut bool) -> bool);
wrap!(jsapi: pub fn SetDelete(cx: *mut JSContext, obj: HandleObject, key: HandleValue, rval: *mut bool) -> bool);
wrap!(jsapi: pub fn SetAdd(cx: *mut JSContext, obj: HandleObject, key: HandleValue) -> bool);
wrap!(jsapi: pub fn SetClear(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn SetKeys(cx: *mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn SetValues(cx: *mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn SetEntries(cx: *mut JSContext, obj: HandleObject, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn SetForEach(cx: *mut JSContext, obj: HandleObject, callbackFn: HandleValue, thisVal: HandleValue) -> bool);
wrap!(jsapi: pub fn ExceptionStackOrNull(obj: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn ExceptionTimeWarpTarget(exn: HandleValue) -> u64);
wrap!(jsapi: pub fn IsWasmModuleObject(obj: HandleObject) -> bool);
wrap!(jsapi: pub fn GetWasmModule(obj: HandleObject) -> RefPtr<WasmModule>);
wrap!(jsapi: pub fn CaptureCurrentStack(cx: *mut JSContext, stackp: MutableHandleObject, capture: *mut StackCapture) -> bool);
wrap!(jsapi: pub fn BuildStackString(cx: *mut JSContext, principals: *mut JSPrincipals, stack: HandleObject, stringp: MutableHandleString, indent: usize, stackFormat: StackFormat) -> bool);
wrap!(jsapi: pub fn ForceLexicalInitialization(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn CloneAndExecuteScript(cx: *mut JSContext, script: Handle<*mut JSScript>, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn CloneAndExecuteScript1(cx: *mut JSContext, envChain: *mut u8, script: Handle<*mut JSScript>, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn Evaluate(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<u16>, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn Evaluate1(cx: *mut JSContext, envChain: *mut u8, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<u16>, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn EvaluateUtf8(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, bytes: *const ::std::os::raw::c_char, length: usize, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn EvaluateUtf8Path(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, filename: *const ::std::os::raw::c_char, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn Compile(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<u16>, script: MutableHandle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn CompileDontInflate(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<Utf8Unit>, script: MutableHandle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn CompileUtf8(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, bytes: *const ::std::os::raw::c_char, length: usize, script: MutableHandle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn CompileUtf8DontInflate(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, bytes: *const ::std::os::raw::c_char, length: usize, script: MutableHandle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn CompileUtf8File(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, file: *mut FILE, script: MutableHandle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn CompileUtf8FileDontInflate(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, file: *mut FILE, script: MutableHandle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn CompileUtf8Path(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, filename: *const ::std::os::raw::c_char, script: MutableHandle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn CompileForNonSyntacticScope(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, srcBuf: *mut SourceText<u16>, script: MutableHandle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn CompileUtf8ForNonSyntacticScope(cx: *mut JSContext, options: *const ReadOnlyCompileOptions, bytes: *const ::std::os::raw::c_char, length: usize, script: MutableHandle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn CompileFunction(cx: *mut JSContext, envChain: *mut u8, options: *const ReadOnlyCompileOptions, name: *const ::std::os::raw::c_char, nargs: ::std::os::raw::c_uint, argnames: *const *const ::std::os::raw::c_char, srcBuf: *mut SourceText<u16>, fun: MutableHandle<*mut JSFunction>) -> bool);
wrap!(jsapi: pub fn CompileFunctionUtf8(cx: *mut JSContext, envChain: *mut u8, options: *const ReadOnlyCompileOptions, name: *const ::std::os::raw::c_char, nargs: ::std::os::raw::c_uint, argnames: *const *const ::std::os::raw::c_char, utf8: *const ::std::os::raw::c_char, length: usize, fun: MutableHandle<*mut JSFunction>) -> bool);
wrap!(jsapi: pub fn InitScriptSourceElement(cx: *mut JSContext, script: Handle<*mut JSScript>, element: HandleObject, elementAttrName: Handle<*mut JSString>) -> bool);
wrap!(jsapi: pub fn ExposeScriptToDebugger(cx: *mut JSContext, script: Handle<*mut JSScript>));
wrap!(jsapi: pub fn OrdinaryToPrimitive(cx: *mut JSContext, obj: HandleObject, type_: JSType, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn ObjectIsDate(cx: *mut JSContext, obj: HandleObject, isDate: *mut bool) -> bool);
wrap!(jsapi: pub fn StrictlyEqual(cx: *mut JSContext, v1: Handle<Value>, v2: Handle<Value>, equal: *mut bool) -> bool);
wrap!(jsapi: pub fn LooselyEqual(cx: *mut JSContext, v1: Handle<Value>, v2: Handle<Value>, equal: *mut bool) -> bool);
wrap!(jsapi: pub fn SameValue(cx: *mut JSContext, v1: Handle<Value>, v2: Handle<Value>, same: *mut bool) -> bool);
wrap!(jsapi: pub fn ToJSONMaybeSafely(cx: *mut JSContext, input: HandleObject, callback: JSONWriteCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn AddSizeOfTab(cx: *mut JSContext, obj: HandleObject, mallocSizeOf: MallocSizeOf, opv: *mut ObjectPrivateVisitor, sizes: *mut TabSizes) -> bool);
wrap!(jsapi: pub fn NewPromiseObject(cx: *mut JSContext, executor: HandleObject, proto: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn IsPromiseObject(obj: HandleObject) -> bool);
wrap!(jsapi: pub fn GetPromiseState(promise: HandleObject) -> PromiseState);
wrap!(jsapi: pub fn GetPromiseID(promise: HandleObject) -> u64);
wrap!(jsapi: pub fn GetPromiseResult(promise: HandleObject) -> Value);
wrap!(jsapi: pub fn GetPromiseIsHandled(promise: HandleObject) -> bool);
wrap!(jsapi: pub fn GetPromiseAllocationSite(promise: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn GetPromiseResolutionSite(promise: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn CallOriginalPromiseResolve(cx: *mut JSContext, resolutionValue: HandleValue) -> *mut JSObject);
wrap!(jsapi: pub fn CallOriginalPromiseReject(cx: *mut JSContext, rejectionValue: HandleValue) -> *mut JSObject);
wrap!(jsapi: pub fn ResolvePromise(cx: *mut JSContext, promiseObj: HandleObject, resolutionValue: HandleValue) -> bool);
wrap!(jsapi: pub fn RejectPromise(cx: *mut JSContext, promiseObj: HandleObject, rejectionValue: HandleValue) -> bool);
wrap!(jsapi: pub fn CallOriginalPromiseThen(cx: *mut JSContext, promise: HandleObject, onFulfilled: HandleObject, onRejected: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn AddPromiseReactions(cx: *mut JSContext, promise: HandleObject, onFulfilled: HandleObject, onRejected: HandleObject) -> bool);
wrap!(jsapi: pub fn GetPromiseUserInputEventHandlingState(promise: HandleObject) -> PromiseUserInputEventHandlingState);
wrap!(jsapi: pub fn SetPromiseUserInputEventHandlingState(promise: HandleObject, state: PromiseUserInputEventHandlingState) -> bool);
wrap!(jsapi: pub fn GetSavedFrameSource(cx: *mut JSContext, principals: *mut JSPrincipals, savedFrame: HandleObject, sourcep: MutableHandle<*mut JSString>, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn GetSavedFrameLine(cx: *mut JSContext, principals: *mut JSPrincipals, savedFrame: HandleObject, linep: *mut u32, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn GetSavedFrameColumn(cx: *mut JSContext, principals: *mut JSPrincipals, savedFrame: HandleObject, columnp: *mut u32, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn GetSavedFrameFunctionDisplayName(cx: *mut JSContext, principals: *mut JSPrincipals, savedFrame: HandleObject, namep: MutableHandle<*mut JSString>, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn GetSavedFrameAsyncCause(cx: *mut JSContext, principals: *mut JSPrincipals, savedFrame: HandleObject, asyncCausep: MutableHandle<*mut JSString>, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn GetSavedFrameAsyncParent(cx: *mut JSContext, principals: *mut JSPrincipals, savedFrame: HandleObject, asyncParentp: MutableHandleObject, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn GetSavedFrameParent(cx: *mut JSContext, principals: *mut JSPrincipals, savedFrame: HandleObject, parentp: MutableHandleObject, selfHosted: SavedFrameSelfHosted) -> SavedFrameResult);
wrap!(jsapi: pub fn NewReadableDefaultStreamObject(cx: *mut JSContext, underlyingSource: HandleObject, size: HandleFunction, highWaterMark: f64, proto: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn NewReadableExternalSourceStreamObject(cx: *mut JSContext, underlyingSource: *mut ReadableStreamUnderlyingSource, proto: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn ReadableStreamGetExternalUnderlyingSource(cx: *mut JSContext, stream: HandleObject, source: *mut *mut ReadableStreamUnderlyingSource) -> bool);
wrap!(jsapi: pub fn ReadableStreamReleaseExternalUnderlyingSource(cx: *mut JSContext, stream: HandleObject) -> bool);
wrap!(jsapi: pub fn ReadableStreamUpdateDataAvailableFromSource(cx: *mut JSContext, stream: HandleObject, availableData: u32) -> bool);
wrap!(jsapi: pub fn ReadableStreamGetMode(cx: *mut JSContext, stream: HandleObject, mode: *mut ReadableStreamMode) -> bool);
wrap!(jsapi: pub fn ReadableStreamIsReadable(cx: *mut JSContext, stream: HandleObject, result: *mut bool) -> bool);
wrap!(jsapi: pub fn ReadableStreamIsLocked(cx: *mut JSContext, stream: HandleObject, result: *mut bool) -> bool);
wrap!(jsapi: pub fn ReadableStreamIsDisturbed(cx: *mut JSContext, stream: HandleObject, result: *mut bool) -> bool);
wrap!(jsapi: pub fn ReadableStreamCancel(cx: *mut JSContext, stream: HandleObject, reason: HandleValue) -> *mut JSObject);
wrap!(jsapi: pub fn ReadableStreamGetReader(cx: *mut JSContext, stream: HandleObject, mode: ReadableStreamReaderMode) -> *mut JSObject);
wrap!(jsapi: pub fn ReadableStreamTee(cx: *mut JSContext, stream: HandleObject, branch1Stream: MutableHandleObject, branch2Stream: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn ReadableStreamClose(cx: *mut JSContext, stream: HandleObject) -> bool);
wrap!(jsapi: pub fn ReadableStreamReaderIsClosed(cx: *mut JSContext, reader: HandleObject, result: *mut bool) -> bool);
wrap!(jsapi: pub fn ReadableStreamEnqueue(cx: *mut JSContext, stream: HandleObject, chunk: HandleValue) -> bool);
wrap!(jsapi: pub fn ReadableStreamError(cx: *mut JSContext, stream: HandleObject, error: HandleValue) -> bool);
wrap!(jsapi: pub fn ReadableStreamReaderCancel(cx: *mut JSContext, reader: HandleObject, reason: HandleValue) -> bool);
wrap!(jsapi: pub fn ReadableStreamReaderReleaseLock(cx: *mut JSContext, reader: HandleObject) -> bool);
wrap!(jsapi: pub fn ReadableStreamDefaultReaderRead(cx: *mut JSContext, reader: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn NewSymbol(cx: *mut JSContext, description: Handle<*mut JSString>) -> *mut Symbol);
wrap!(jsapi: pub fn GetSymbolFor(cx: *mut JSContext, key: Handle<*mut JSString>) -> *mut Symbol);
wrap!(jsapi: pub fn GetSymbolDescription(symbol: Handle<*mut Symbol>) -> *mut JSString);
wrap!(jsapi: pub fn GetSymbolCode(symbol: Handle<*mut Symbol>) -> SymbolCode);
wrap!(jsapi: pub fn GetBuiltinClass(cx: *mut JSContext, obj: HandleObject, cls: *mut ESClass) -> bool);
wrap!(jsapi: pub fn IsArgumentsObject(obj: HandleObject) -> bool);
wrap!(jsapi: pub fn ObjectClassName(cx: *mut JSContext, obj: HandleObject) -> *const ::std::os::raw::c_char);
wrap!(jsapi: pub fn EnqueueJob(cx: *mut JSContext, job: HandleObject) -> bool);
wrap!(jsapi: pub fn AssertSameCompartment1(cx: *mut JSContext, v: HandleValue));
wrap!(jsapi: pub fn GetObjectProto(cx: *mut JSContext, obj: HandleObject, proto: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn GetRealmOriginalEval(cx: *mut JSContext, eval: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn GetPropertyKeys(cx: *mut JSContext, obj: HandleObject, flags: ::std::os::raw::c_uint, props: *mut AutoIdVector) -> bool);
wrap!(jsapi: pub fn RegExpToSharedNonInline(cx: *mut JSContext, regexp: HandleObject) -> *mut RegExpShared);
wrap!(jsapi: pub fn DateIsValid(cx: *mut JSContext, obj: HandleObject, isValid: *mut bool) -> bool);
wrap!(jsapi: pub fn DateGetMsecSinceEpoch(cx: *mut JSContext, obj: HandleObject, msecSinceEpoch: *mut f64) -> bool);
wrap!(jsapi: pub fn PrepareScriptEnvironmentAndInvoke(cx: *mut JSContext, global: HandleObject, closure: *mut ScriptEnvironmentPreparer_Closure));
wrap!(jsapi: pub fn GetElementsWithAdder(cx: *mut JSContext, obj: HandleObject, receiver: HandleObject, begin: u32, end: u32, adder: *mut ElementAdder) -> bool);
wrap!(jsapi: pub fn SetPropertyIgnoringNamedGetter(cx: *mut JSContext, obj: HandleObject, id: HandleId, v: HandleValue, receiver: HandleValue, ownDesc: Handle<PropertyDescriptor>, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn ExecuteInFrameScriptEnvironment(cx: *mut JSContext, obj: HandleObject, script: HandleScript, scope: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn ExecuteInJSMEnvironment(cx: *mut JSContext, script: HandleScript, jsmEnv: HandleObject) -> bool);
wrap!(jsapi: pub fn ExecuteInJSMEnvironment1(cx: *mut JSContext, script: HandleScript, jsmEnv: HandleObject, targetObj: *mut AutoObjectVector) -> bool);
wrap!(jsapi: pub fn ReportIsNotFunction(cx: *mut JSContext, v: HandleValue) -> bool);
wrap!(jsapi: pub fn SetWindowProxy(cx: *mut JSContext, global: HandleObject, windowProxy: HandleObject));
wrap!(jsapi: pub fn AddMozDateTimeFormatConstructor(cx: *mut JSContext, intl: HandleObject) -> bool);
wrap!(jsapi: pub fn SetRealmValidAccessPtr(cx: *mut JSContext, global: HandleObject, accessp: *mut bool));
wrap!(jsapi: pub fn ToBooleanSlow(v: HandleValue) -> bool);
wrap!(jsapi: pub fn ToNumberSlow(cx: *mut JSContext, v: HandleValue, dp: *mut f64) -> bool);
wrap!(jsapi: pub fn ToInt8Slow(cx: *mut JSContext, v: HandleValue, out: *mut i8) -> bool);
wrap!(jsapi: pub fn ToUint8Slow(cx: *mut JSContext, v: HandleValue, out: *mut u8) -> bool);
wrap!(jsapi: pub fn ToInt16Slow(cx: *mut JSContext, v: HandleValue, out: *mut i16) -> bool);
wrap!(jsapi: pub fn ToInt32Slow(cx: *mut JSContext, v: HandleValue, out: *mut i32) -> bool);
wrap!(jsapi: pub fn ToUint32Slow(cx: *mut JSContext, v: HandleValue, out: *mut u32) -> bool);
wrap!(jsapi: pub fn ToUint16Slow(cx: *mut JSContext, v: HandleValue, out: *mut u16) -> bool);
wrap!(jsapi: pub fn ToInt64Slow(cx: *mut JSContext, v: HandleValue, out: *mut i64) -> bool);
wrap!(jsapi: pub fn ToUint64Slow(cx: *mut JSContext, v: HandleValue, out: *mut u64) -> bool);
wrap!(jsapi: pub fn ToStringSlow(cx: *mut JSContext, v: HandleValue) -> *mut JSString);
wrap!(jsapi: pub fn ToObjectSlow(cx: *mut JSContext, v: HandleValue, reportScanStack: bool) -> *mut JSObject);
wrap!(jsapi: pub fn GetFirstSubsumedSavedFrame(cx: *mut JSContext, principals: *mut JSPrincipals, savedFrame: HandleObject, selfHosted: SavedFrameSelfHosted) -> *mut JSObject);
wrap!(jsapi: pub fn JS_EncodeStringToUTF8(cx: *mut JSContext, str: Handle<*mut JSString>) -> UniqueChars);
wrap!(jsapi: pub fn JS_ValueToObject(cx: *mut JSContext, v: HandleValue, objp: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_ValueToFunction(cx: *mut JSContext, v: HandleValue) -> *mut JSFunction);
wrap!(jsapi: pub fn JS_ValueToConstructor(cx: *mut JSContext, v: HandleValue) -> *mut JSFunction);
wrap!(jsapi: pub fn JS_ValueToSource(cx: *mut JSContext, v: Handle<Value>) -> *mut JSString);
wrap!(jsapi: pub fn JS_TypeOfValue(cx: *mut JSContext, v: Handle<Value>) -> JSType);
wrap!(jsapi: pub fn JS_WrapObject(cx: *mut JSContext, objp: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_WrapValue(cx: *mut JSContext, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_TransplantObject(cx: *mut JSContext, origobj: HandleObject, target: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_RefreshCrossCompartmentWrappers(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_ResolveStandardClass(cx: *mut JSContext, obj: HandleObject, id: HandleId, resolved: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_EnumerateStandardClasses(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_NewEnumerateStandardClasses(cx: *mut JSContext, obj: HandleObject, properties: *mut AutoIdVector, enumerableOnly: bool) -> bool);
wrap!(jsapi: pub fn JS_NewEnumerateStandardClassesIncludingResolved(cx: *mut JSContext, obj: HandleObject, properties: *mut AutoIdVector, enumerableOnly: bool) -> bool);
wrap!(jsapi: pub fn JS_GetClassObject(cx: *mut JSContext, key: JSProtoKey, objp: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_GetClassPrototype(cx: *mut JSContext, key: JSProtoKey, objp: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_IdToProtoKey(cx: *mut JSContext, id: HandleId) -> JSProtoKey);
wrap!(jsapi: pub fn JS_InitReflectParse(cx: *mut JSContext, global: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_DefineProfilingFunctions(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_DefineDebuggerObject(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_ValueToId(cx: *mut JSContext, v: HandleValue, idp: MutableHandleId) -> bool);
wrap!(jsapi: pub fn JS_StringToId(cx: *mut JSContext, s: HandleString, idp: MutableHandleId) -> bool);
wrap!(jsapi: pub fn JS_IdToValue(cx: *mut JSContext, id: jsid, vp: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_InitClass(cx: *mut JSContext, obj: HandleObject, parent_proto: HandleObject, clasp: *const JSClass, constructor: JSNative, nargs: ::std::os::raw::c_uint, ps: *const JSPropertySpec, fs: *const JSFunctionSpec, static_ps: *const JSPropertySpec, static_fs: *const JSFunctionSpec) -> *mut JSObject);
wrap!(jsapi: pub fn JS_LinkConstructorAndPrototype(cx: *mut JSContext, ctor: HandleObject, proto: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_InstanceOf(cx: *mut JSContext, obj: HandleObject, clasp: *const JSClass, args: *mut CallArgs) -> bool);
wrap!(jsapi: pub fn JS_HasInstance(cx: *mut JSContext, obj: HandleObject, v: Handle<Value>, bp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_GetInstancePrivate(cx: *mut JSContext, obj: HandleObject, clasp: *const JSClass, args: *mut CallArgs) -> *mut ::std::os::raw::c_void);
wrap!(jsapi: pub fn JS_GetConstructor(cx: *mut JSContext, proto: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_FireOnNewGlobalObject(cx: *mut JSContext, global: HandleObject));
wrap!(jsapi: pub fn JS_NewObjectWithGivenProto(cx: *mut JSContext, clasp: *const JSClass, proto: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_DeepFreezeObject(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_FreezeObject(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_GetPrototype(cx: *mut JSContext, obj: HandleObject, result: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_GetPrototypeIfOrdinary(cx: *mut JSContext, obj: HandleObject, isOrdinary: *mut bool, result: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_SetPrototype(cx: *mut JSContext, obj: HandleObject, proto: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_IsExtensible(cx: *mut JSContext, obj: HandleObject, extensible: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_PreventExtensions(cx: *mut JSContext, obj: HandleObject, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_SetImmutablePrototype(cx: *mut JSContext, obj: HandleObject, succeeded: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_GetOwnPropertyDescriptorById(cx: *mut JSContext, obj: HandleObject, id: HandleId, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn JS_GetOwnPropertyDescriptor(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn JS_GetOwnUCPropertyDescriptor(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn JS_GetPropertyDescriptorById(cx: *mut JSContext, obj: HandleObject, id: HandleId, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn JS_GetPropertyDescriptor(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn JS_GetUCPropertyDescriptor(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, desc: Handle<PropertyDescriptor>, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById1(cx: *mut JSContext, obj: HandleObject, id: HandleId, desc: Handle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById2(cx: *mut JSContext, obj: HandleObject, id: HandleId, value: HandleValue, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById3(cx: *mut JSContext, obj: HandleObject, id: HandleId, getter: JSNative, setter: JSNative, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById4(cx: *mut JSContext, obj: HandleObject, id: HandleId, getter: HandleObject, setter: HandleObject, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById5(cx: *mut JSContext, obj: HandleObject, id: HandleId, value: HandleObject, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById6(cx: *mut JSContext, obj: HandleObject, id: HandleId, value: HandleString, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById7(cx: *mut JSContext, obj: HandleObject, id: HandleId, value: i32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById8(cx: *mut JSContext, obj: HandleObject, id: HandleId, value: u32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefinePropertyById9(cx: *mut JSContext, obj: HandleObject, id: HandleId, value: f64, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, value: HandleValue, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty1(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, getter: JSNative, setter: JSNative, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty2(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, getter: HandleObject, setter: HandleObject, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty3(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, value: HandleObject, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty4(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, value: HandleString, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty5(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, value: i32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty6(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, value: u32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineProperty7(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, value: f64, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, desc: Handle<PropertyDescriptor>, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty1(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, desc: Handle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty2(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, value: HandleValue, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty3(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, getter: HandleObject, setter: HandleObject, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty4(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, value: HandleObject, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty5(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, value: HandleString, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty6(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, value: i32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty7(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, value: u32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineUCProperty8(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, value: f64, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement(cx: *mut JSContext, obj: HandleObject, index: u32, value: HandleValue, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement1(cx: *mut JSContext, obj: HandleObject, index: u32, getter: HandleObject, setter: HandleObject, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement2(cx: *mut JSContext, obj: HandleObject, index: u32, value: HandleObject, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement3(cx: *mut JSContext, obj: HandleObject, index: u32, value: HandleString, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement4(cx: *mut JSContext, obj: HandleObject, index: u32, value: i32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement5(cx: *mut JSContext, obj: HandleObject, index: u32, value: u32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_DefineElement6(cx: *mut JSContext, obj: HandleObject, index: u32, value: f64, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(jsapi: pub fn JS_HasPropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_HasProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_HasUCProperty(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, vp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_HasElement(cx: *mut JSContext, obj: HandleObject, index: u32, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_HasOwnPropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_HasOwnProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_ForwardGetPropertyTo(cx: *mut JSContext, obj: HandleObject, id: HandleId, receiver: HandleValue, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_ForwardGetElementTo(cx: *mut JSContext, obj: HandleObject, index: u32, receiver: HandleObject, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_GetPropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_GetProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_GetUCProperty(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_GetElement(cx: *mut JSContext, obj: HandleObject, index: u32, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_ForwardSetPropertyTo(cx: *mut JSContext, obj: HandleObject, id: HandleId, v: HandleValue, receiver: HandleValue, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_SetPropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, v: HandleValue) -> bool);
wrap!(jsapi: pub fn JS_SetProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, v: HandleValue) -> bool);
wrap!(jsapi: pub fn JS_SetUCProperty(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, v: HandleValue) -> bool);
wrap!(jsapi: pub fn JS_SetElement(cx: *mut JSContext, obj: HandleObject, index: u32, v: HandleValue) -> bool);
wrap!(jsapi: pub fn JS_SetElement1(cx: *mut JSContext, obj: HandleObject, index: u32, v: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_SetElement2(cx: *mut JSContext, obj: HandleObject, index: u32, v: HandleString) -> bool);
wrap!(jsapi: pub fn JS_SetElement3(cx: *mut JSContext, obj: HandleObject, index: u32, v: i32) -> bool);
wrap!(jsapi: pub fn JS_SetElement4(cx: *mut JSContext, obj: HandleObject, index: u32, v: u32) -> bool);
wrap!(jsapi: pub fn JS_SetElement5(cx: *mut JSContext, obj: HandleObject, index: u32, v: f64) -> bool);
wrap!(jsapi: pub fn JS_DeletePropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_DeleteProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_DeleteUCProperty(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_DeleteElement(cx: *mut JSContext, obj: HandleObject, index: u32, result: *mut ObjectOpResult) -> bool);
wrap!(jsapi: pub fn JS_DeletePropertyById1(cx: *mut JSContext, obj: HandleObject, id: jsid) -> bool);
wrap!(jsapi: pub fn JS_DeleteProperty1(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char) -> bool);
wrap!(jsapi: pub fn JS_DeleteElement1(cx: *mut JSContext, obj: HandleObject, index: u32) -> bool);
wrap!(jsapi: pub fn JS_CallFunctionValue(cx: *mut JSContext, obj: HandleObject, fval: HandleValue, args: *const HandleValueArray, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_CallFunction(cx: *mut JSContext, obj: HandleObject, fun: HandleFunction, args: *const HandleValueArray, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_CallFunctionName(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, args: *const HandleValueArray, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_New(cx: *mut JSContext, ctor: HandleObject, args: *const HandleValueArray) -> *mut JSObject);
wrap!(jsapi: pub fn JS_DefineObject(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, clasp: *const JSClass, attrs: ::std::os::raw::c_uint) -> *mut JSObject);
wrap!(jsapi: pub fn JS_DefineConstDoubles(cx: *mut JSContext, obj: HandleObject, cds: *const JSConstDoubleSpec) -> bool);
wrap!(jsapi: pub fn JS_DefineConstIntegers(cx: *mut JSContext, obj: HandleObject, cis: *const JSConstIntegerSpec) -> bool);
wrap!(jsapi: pub fn JS_DefineProperties(cx: *mut JSContext, obj: HandleObject, ps: *const JSPropertySpec) -> bool);
wrap!(jsapi: pub fn JS_AlreadyHasOwnPropertyById(cx: *mut JSContext, obj: HandleObject, id: HandleId, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_AlreadyHasOwnProperty(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_AlreadyHasOwnUCProperty(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_AlreadyHasOwnElement(cx: *mut JSContext, obj: HandleObject, index: u32, foundp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_NewArrayObject(cx: *mut JSContext, contents: *const HandleValueArray) -> *mut JSObject);
wrap!(jsapi: pub fn JS_IsArrayObject(cx: *mut JSContext, value: HandleValue, isArray: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_IsArrayObject1(cx: *mut JSContext, obj: HandleObject, isArray: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_GetArrayLength(cx: *mut JSContext, obj: HandleObject, lengthp: *mut u32) -> bool);
wrap!(jsapi: pub fn JS_SetArrayLength(cx: *mut JSContext, obj: HandleObject, length: u32) -> bool);
wrap!(jsapi: pub fn JS_StealArrayBufferContents(cx: *mut JSContext, obj: HandleObject) -> *mut ::std::os::raw::c_void);
wrap!(jsapi: pub fn JS_ExternalizeArrayBufferContents(cx: *mut JSContext, obj: HandleObject) -> *mut ::std::os::raw::c_void);
wrap!(jsapi: pub fn JS_GetFunctionLength(cx: *mut JSContext, fun: HandleFunction, length: *mut u16) -> bool);
wrap!(jsapi: pub fn JS_DefineFunctions(cx: *mut JSContext, obj: HandleObject, fs: *const JSFunctionSpec) -> bool);
wrap!(jsapi: pub fn JS_DefineFunction(cx: *mut JSContext, obj: HandleObject, name: *const ::std::os::raw::c_char, call: JSNative, nargs: ::std::os::raw::c_uint, attrs: ::std::os::raw::c_uint) -> *mut JSFunction);
wrap!(jsapi: pub fn JS_DefineUCFunction(cx: *mut JSContext, obj: HandleObject, name: *const u16, namelen: usize, call: JSNative, nargs: ::std::os::raw::c_uint, attrs: ::std::os::raw::c_uint) -> *mut JSFunction);
wrap!(jsapi: pub fn JS_DefineFunctionById(cx: *mut JSContext, obj: HandleObject, id: Handle<jsid>, call: JSNative, nargs: ::std::os::raw::c_uint, attrs: ::std::os::raw::c_uint) -> *mut JSFunction);
wrap!(jsapi: pub fn JS_GetFunctionScript(cx: *mut JSContext, fun: HandleFunction) -> *mut JSScript);
wrap!(jsapi: pub fn JS_DecompileScript(cx: *mut JSContext, script: Handle<*mut JSScript>) -> *mut JSString);
wrap!(jsapi: pub fn JS_DecompileFunction(cx: *mut JSContext, fun: Handle<*mut JSFunction>) -> *mut JSString);
wrap!(jsapi: pub fn JS_AtomizeAndPinJSString(cx: *mut JSContext, str: HandleString) -> *mut JSString);
wrap!(jsapi: pub fn JS_NewDependentString(cx: *mut JSContext, str: HandleString, start: usize, length: usize) -> *mut JSString);
wrap!(jsapi: pub fn JS_ConcatStrings(cx: *mut JSContext, left: HandleString, right: HandleString) -> *mut JSString);
wrap!(jsapi: pub fn JS_SetRegExpInput(cx: *mut JSContext, obj: HandleObject, input: HandleString) -> bool);
wrap!(jsapi: pub fn JS_ClearRegExpStatics(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_ExecuteRegExp(cx: *mut JSContext, obj: HandleObject, reobj: HandleObject, chars: *mut u16, length: usize, indexp: *mut usize, test: bool, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_ExecuteRegExpNoStatics(cx: *mut JSContext, reobj: HandleObject, chars: *mut u16, length: usize, indexp: *mut usize, test: bool, rval: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_ObjectIsRegExp(cx: *mut JSContext, obj: HandleObject, isRegExp: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_GetRegExpFlags(cx: *mut JSContext, obj: HandleObject) -> ::std::os::raw::c_uint);
wrap!(jsapi: pub fn JS_GetRegExpSource(cx: *mut JSContext, obj: HandleObject) -> *mut JSString);
wrap!(jsapi: pub fn JS_GetPendingException(cx: *mut JSContext, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_SetPendingException(cx: *mut JSContext, v: HandleValue));
wrap!(jsapi: pub fn JS_ErrorFromException(cx: *mut JSContext, obj: HandleObject) -> *mut JSErrorReport);
wrap!(jsapi: pub fn JS_IndexToId(cx: *mut JSContext, index: u32, arg1: MutableHandleId) -> bool);
wrap!(jsapi: pub fn JS_CharsToId(cx: *mut JSContext, chars: TwoByteChars, arg1: MutableHandleId) -> bool);
wrap!(jsapi: pub fn JS_IsIdentifier(cx: *mut JSContext, str: HandleString, isIdentifier: *mut bool) -> bool);
wrap!(jsapi: pub fn JS_FindCompilationScope(cx: *mut JSContext, obj: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_SplicePrototype(cx: *mut JSContext, obj: HandleObject, proto: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_NewObjectWithUniqueType(cx: *mut JSContext, clasp: *const JSClass, proto: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewObjectWithoutMetadata(cx: *mut JSContext, clasp: *const JSClass, proto: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NondeterministicGetWeakMapKeys(cx: *mut JSContext, obj: HandleObject, ret: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_NondeterministicGetWeakSetKeys(cx: *mut JSContext, obj: HandleObject, ret: MutableHandleObject) -> bool);
wrap!(jsapi: pub fn JS_CloneObject(cx: *mut JSContext, obj: HandleObject, proto: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_InitializePropertiesFromCompatibleNativeObject(cx: *mut JSContext, dst: HandleObject, src: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_CopyPropertiesFrom(cx: *mut JSContext, target: HandleObject, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_CopyPropertyFrom(cx: *mut JSContext, id: HandleId, target: HandleObject, obj: HandleObject, copyBehavior: PropertyCopyBehavior) -> bool);
wrap!(jsapi: pub fn JS_WrapPropertyDescriptor(cx: *mut JSContext, desc: MutableHandle<PropertyDescriptor>) -> bool);
wrap!(jsapi: pub fn JS_DefineFunctionsWithHelp(cx: *mut JSContext, obj: HandleObject, fs: *const JSFunctionSpecWithHelp) -> bool);
wrap!(jsapi: pub fn JS_NewInt8ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint8ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint8ClampedArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewInt16ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint16ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewInt32ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint32ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewFloat32ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewFloat64ArrayFromArray(cx: *mut JSContext, array: HandleObject) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewInt8ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint8ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint8ClampedArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewInt16ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint16ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewInt32ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewUint32ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewFloat32ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(jsapi: pub fn JS_NewFloat64ArrayWithBuffer(cx: *mut JSContext, arrayBuffer: HandleObject, byteOffset: u32, length: i32) -> *mut JSObject);
wrap!(jsapi: pub fn JS_GetArrayBufferViewBuffer(cx: *mut JSContext, obj: HandleObject, isSharedMemory: *mut bool) -> *mut JSObject);
wrap!(jsapi: pub fn JS_DetachArrayBuffer(cx: *mut JSContext, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_NewDataView(cx: *mut JSContext, buffer: HandleObject, byteOffset: u32, byteLength: i32) -> *mut JSObject);
wrap!(jsapi: pub fn JS_Utf8BufferIsCompilableUnit(cx: *mut JSContext, obj: HandleObject, utf8: *const ::std::os::raw::c_char, length: usize) -> bool);
wrap!(jsapi: pub fn JS_ExecuteScript(cx: *mut JSContext, script: Handle<*mut JSScript>, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_ExecuteScript1(cx: *mut JSContext, script: Handle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn JS_ExecuteScript2(cx: *mut JSContext, envChain: *mut u8, script: Handle<*mut JSScript>, rval: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_ExecuteScript3(cx: *mut JSContext, envChain: *mut u8, script: Handle<*mut JSScript>) -> bool);
wrap!(jsapi: pub fn JS_Stringify(cx: *mut JSContext, value: MutableHandle<Value>, replacer: HandleObject, space: Handle<Value>, callback: JSONWriteCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn JS_ParseJSON(cx: *mut JSContext, chars: *const u16, len: u32, vp: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_ParseJSON1(cx: *mut JSContext, str: Handle<*mut JSString>, vp: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_ParseJSONWithReviver(cx: *mut JSContext, chars: *const u16, len: u32, reviver: Handle<Value>, vp: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_ParseJSONWithReviver1(cx: *mut JSContext, str: Handle<*mut JSString>, reviver: Handle<Value>, vp: MutableHandle<Value>) -> bool);
wrap!(jsapi: pub fn JS_ReadStructuredClone(cx: *mut JSContext, data: *mut JSStructuredCloneData, version: u32, scope: StructuredCloneScope, vp: MutableHandleValue, optionalCallbacks: *const JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn JS_WriteStructuredClone(cx: *mut JSContext, v: HandleValue, data: *mut JSStructuredCloneData, scope: StructuredCloneScope, cloneDataPolicy: CloneDataPolicy, optionalCallbacks: *const JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void, transferable: HandleValue) -> bool);
wrap!(jsapi: pub fn JS_StructuredClone(cx: *mut JSContext, v: HandleValue, vp: MutableHandleValue, optionalCallbacks: *const JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void) -> bool);
wrap!(jsapi: pub fn JS_ReadTypedArray(r: *mut JSStructuredCloneReader, vp: MutableHandleValue) -> bool);
wrap!(jsapi: pub fn JS_WriteString(w: *mut JSStructuredCloneWriter, str: HandleString) -> bool);
wrap!(jsapi: pub fn JS_WriteTypedArray(w: *mut JSStructuredCloneWriter, v: HandleValue) -> bool);
wrap!(jsapi: pub fn JS_ObjectNotWritten(w: *mut JSStructuredCloneWriter, obj: HandleObject) -> bool);
wrap!(jsapi: pub fn JS_ForOfIteratorInit(iterator: *mut ForOfIterator, iterable: HandleValue, nonIterableBehavior: ForOfIterator_NonIterableBehavior) -> bool);
wrap!(jsapi: pub fn JS_ForOfIteratorNext(iterator: *mut ForOfIterator, val: MutableHandleValue, done: *mut bool) -> bool);
